// Generic functions related to numbers.
package main

import (
	"math/big"
	"fmt"
)

type integer interface {
	type int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr;
}

type float interface {
	type float32, float64;
}

type number interface {
	// Q. is there a shorter syntax 'for integer + float'?
	type int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64;
}

// The following functions are "traits" defined in terms of ad-hoc polymorphism.
// The code generated by the compiler is currently very poor.
// Such polymorphism is quite restricted: for example,
// you can't say z=x+y in case int and z.Add(x, y) in case *big.Int.

// Bits returns the number of bits in an integer or float.
func Bits[T number]() int {
	// Is there a less clumsy syntax for this?
	switch (interface{}(*new(T))).(type) {
	case int, uint, uintptr:
		return 0 // TODO return sizeof(x)/8
	case int8, uint8: 
		return 8
	case int16, uint16: 
		return 16
	case int32, uint32, float32: 
		return 32
	case int64, uint64, float64: 
		return 64
	}
	panic("unreachable")
}

func Signed[T integer]() bool {
	switch (interface{}(Zero[T]())).(type) {
	case int, int8, int16, int32, int64:
		return true
	}
	return false
}

// Max returns the maximum value of integer type T.
func Max[T integer]() T {
	bits := Bits[T]()
	if Signed[T]() {
		return 1<<(bits-1) - 1
	} else {
		return (1<<bits)-1
	}
}

// Min returns the minimum value of integer type T.
func Min[T integer]() T {
	if Signed[T]() {
		bits := Bits[T]()
		return 1<<(bits-1)
	} else {
		return 0
	}
}

// Zero returns the zero value of T, aka *new(T).
func Zero[T any]() (_ T) { return; }

// Abs returns the absolute value of an integer.
func Abs[T integer](x T) T {
	if x < 0 {
		return -x
	} else {
		return x
	}
}


// -- complex numbers, user defined: a totally adequate replacement --

type complex64 = Complex[float32]
type complex128 = Complex[float64]

type Complex[T float] struct { re, im T }

func (z Complex[T]) Real() T { return z.re }
func (z Complex[T]) Imag() T { return z.im }

func (z Complex[T]) String() string { return fmt.Sprintf("(%g+%gi)", z.re, z.im) }


func (x Complex[T]) Add(y Complex[T]) Complex[T] {
	return Complex[T]{x.re + y.re, x.im + y.im}
}

func (x Complex[T]) Mul(y Complex[T]) Complex[T] {
	return Complex[T]{x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re}
}

// --test--

// The compiler generates 126 bytes of code for this function.
// Optimization is clearly needed to turn it into a constant.
func maxuint16() uint16 {
	return Max[uint16]();
}

func main() {
	fmt.Println(Min[uint16](), Max[uint16]()) // 0 65535
	fmt.Println(Min[int16](), Max[int16]())	// -32768 32767
	fmt.Println(Signed[int16]()) // true

	x := complex64{1, 2}
	y := complex64{2, 3}
	fmt.Println(x, y, x.Add(y), x.Mul(y)) // (1+2i) (2+3i) (3+5i) (-4+7i)
}
