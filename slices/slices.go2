// Generic algorithms over slices.
package main

import (
	"fmt"
	"unsafe"
)

// TODO: sort, uniq, filter, etc

// TODO: q. is the GC ok with all the unsafe hacks?

// A user-defined slice type, to demonstrate that the runtime slice type can now
// be implemented within the language.
// We tried *[maxint]T for the data field, but it exceeds the size of the address space.
// (We can't use maxint/unsafe.Sizeof(T) in case T is a zero-length type.)
// data could equally be an unsafe.Pointer: the same number of casts are needed,
// but in different places; in particular, offset() calls don't need offset[T]).
// We prefer *T for clarity.
type Slice[T any] struct {
	data     *T // pointer to an element of an array of type [n]T
	len, cap int
}

func (s Slice[T]) Len() int { return s.len }
func (s Slice[T]) Cap() int { return s.cap }
func (s Slice[T]) IsNil() bool { return s.data == nil }
func (s Slice[T]) Addr(i int) *T {
	if 0 <= i && i < s.len {
		return offset(s.data, i)
	}
	panic("index out of range")
}
func (s Slice[T]) Elem(i int) T { return *s.Addr(i) }
func (s Slice[T]) Append(elems...T) Slice[T] {
	newlen := s.len + len(elems)
	newcap := s.cap
	if newlen > s.cap {
		// Expand capacity by doubling to ensure geometric growth.
		newcap = max(newlen, s.len * 2)
		new := make([]T, newcap)
		copy(new, s.ToSlice())
		s.data = fromRuntime(new).data
	}
	for i, elem := range elems {
		*offset(s.data, s.len + i) = elem
	}
	s.len = newlen
	s.cap = newcap
	return s
}
func (s Slice[T]) AppendSlice(t Slice[T]) Slice[T] { return s.Append(s.ToSlice()...) }
func (s Slice[T]) ToSlice() []T { return toRuntime(s) }
func (s Slice[T]) String() string { return fmt.Sprint(s.ToSlice()) }
// Equivalent to s[i:j].
func (s Slice[T]) Slice(i, j int) Slice[T] {
	if 0 <= i && i <= j && j <= s.len {
		s.len = j - i
		s.cap -= i
		s.data = offset(s.data, i)
		return s;
	}
	panic("indices out of range")
}
// Equivalent to s[::cap].
func (s Slice[T]) WithCap(cap int) Slice[T] {
	if cap < s.len {
		panic("invalid cap index")
	}
	return Slice[T]{s.data, s.len, cap}
}

// -- unsafe hacks ---

type uP = unsafe.Pointer

func offset[T any](data *T, index int) *T {
	return (*T)(uP(uintptr(uP(data)) + sizeof[T]() * uintptr(index)))
}

// Why does unsafe.Sizeof(T) not work, when we can implement it in the language thus?
func sizeof[T any]() uintptr {
	var array [2]T
	return uintptr(uP(&array[1])) - uintptr(uP(&array[0]))
}

func fromRuntime[T any](slice []T) Slice[T] {
	return *(*Slice[T])(uP(&slice))
}

func toRuntime[T any](slice Slice[T]) []T {
	return *(*[]T)(uP(&slice))
}

// -- utils --
		
func max(x, y int) int {
	if x > y {
		return x
	} else {
		return y
	}
}

// --test--

func main() {
	var s Slice[string]
	s = s.Append("hello")
	s = s.Append("world")
	s = s.AppendSlice(s)
	fmt.Println(s) // [hello world hello world]
	s = s.Slice(0, 3)
	fmt.Println(s) // [hello world hello]
	*s.Addr(2) = "goodbye"
	fmt.Println(s) // [hello world goodbye]

	// discard odd elements, in place (destroys s)
	out := s.Slice(0, 0) // zero-length prefix
	for i := 0; i < s.Len(); i++ {
		if i & 1 == 0 {
			out = out.Append(s.Elem(i))
		}
	}
	fmt.Println(out) // [hello goodbye]
}

