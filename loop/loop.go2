// Parallel loops.
package main

import (
	"fmt"
	"sync"
)

// TODO errors, cancellation. Each case is not very interesting, but the question is:
// do the variants compose nicely, or merely lead to a pile of combinations, few of
// which are worth offering in a library? I suspect the latter.

// Calls f(x) for x in elems, in parallel.
func ForEach[T any](elems []T, f func(T)) {
	var wg sync.WaitGroup
	for _, elem := range elems {
		wg.Add(1)
		go func(elem T) {
			f(elem)
			wg.Done()
		}(elem)
	}
	wg.Wait()
}

// Computes [f(x) for x in elems] in parallel.
func Map[A, B any](elems []A, f func(A) B) []B {
	res := make([]B, len(elems))
	var wg sync.WaitGroup
	wg.Add(len(elems))
	for i, x := range elems {
		go func(i int, x A) {
			res[i] = f(x)
			wg.Done()
		}(i, x)
	}
	wg.Wait()
	return res
}

// --test--

func main() {
	ForEach([]int{1, 2, 3}, func(x int) { fmt.Println(x) }) // prints 1, 2, 3 concurrently

	fmt.Println(Map([]int{1, 2, 3}, func(x int) string { return fmt.Sprint(x*x) })) // [1 4 9]
}
